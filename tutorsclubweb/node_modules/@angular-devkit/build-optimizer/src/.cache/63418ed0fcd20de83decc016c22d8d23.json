{"remainingRequest":"D:\\TutorsClubBitBucket\\tutorsclubweb\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\TutorsClubBitBucket\\tutorsclubweb\\node_modules\\@swimlane\\ngx-datatable\\release\\utils\\math.js","dependencies":[{"path":"D:\\TutorsClubBitBucket\\tutorsclubweb\\node_modules\\@swimlane\\ngx-datatable\\release\\utils\\math.js","mtime":1533191675711},{"path":"D:\\TutorsClubBitBucket\\tutorsclubweb\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1533191679839},{"path":"D:\\TutorsClubBitBucket\\tutorsclubweb\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1533191671924}],"contextDependencies":[],"result":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar column_1 = require(\"./column\");\r\n/**\r\n * Calculates the Total Flex Grow\r\n */\r\nfunction getTotalFlexGrow(columns) {\r\n    var totalFlexGrow = 0;\r\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\r\n        var c = columns_1[_i];\r\n        totalFlexGrow += c.flexGrow || 0;\r\n    }\r\n    return totalFlexGrow;\r\n}\r\nexports.getTotalFlexGrow = getTotalFlexGrow;\r\n/**\r\n * Adjusts the column widths.\r\n * Inspired by: https://github.com/facebook/fixed-data-table/blob/master/src/FixedDataTableWidthHelper.js\r\n */\r\nfunction adjustColumnWidths(allColumns, expectedWidth) {\r\n    var columnsWidth = column_1.columnsTotalWidth(allColumns);\r\n    var totalFlexGrow = getTotalFlexGrow(allColumns);\r\n    var colsByGroup = column_1.columnsByPin(allColumns);\r\n    if (columnsWidth !== expectedWidth) {\r\n        scaleColumns(colsByGroup, expectedWidth, totalFlexGrow);\r\n    }\r\n}\r\nexports.adjustColumnWidths = adjustColumnWidths;\r\n/**\r\n * Resizes columns based on the flexGrow property, while respecting manually set widths\r\n */\r\nfunction scaleColumns(colsByGroup, maxWidth, totalFlexGrow) {\r\n    // calculate total width and flexgrow points for coulumns that can be resized\r\n    for (var attr in colsByGroup) {\r\n        for (var _i = 0, _a = colsByGroup[attr]; _i < _a.length; _i++) {\r\n            var column = _a[_i];\r\n            if (!column.canAutoResize) {\r\n                maxWidth -= column.width;\r\n                totalFlexGrow -= column.flexGrow ? column.flexGrow : 0;\r\n            }\r\n            else {\r\n                column.width = 0;\r\n            }\r\n        }\r\n    }\r\n    var hasMinWidth = {};\r\n    var remainingWidth = maxWidth;\r\n    // resize columns until no width is left to be distributed\r\n    do {\r\n        var widthPerFlexPoint = remainingWidth / totalFlexGrow;\r\n        remainingWidth = 0;\r\n        for (var attr in colsByGroup) {\r\n            for (var _b = 0, _c = colsByGroup[attr]; _b < _c.length; _b++) {\r\n                var column = _c[_b];\r\n                // if the column can be resize and it hasn't reached its minimum width yet\r\n                if (column.canAutoResize && !hasMinWidth[column.prop]) {\r\n                    var newWidth = column.width + column.flexGrow * widthPerFlexPoint;\r\n                    if (column.minWidth !== undefined && newWidth < column.minWidth) {\r\n                        remainingWidth += newWidth - column.minWidth;\r\n                        column.width = column.minWidth;\r\n                        hasMinWidth[column.prop] = true;\r\n                    }\r\n                    else {\r\n                        column.width = newWidth;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } while (remainingWidth !== 0);\r\n}\r\n/**\r\n * Forces the width of the columns to\r\n * distribute equally but overflowing when necessary\r\n *\r\n * Rules:\r\n *\r\n *  - If combined withs are less than the total width of the grid,\r\n *    proportion the widths given the min / max / normal widths to fill the width.\r\n *\r\n *  - If the combined widths, exceed the total width of the grid,\r\n *    use the standard widths.\r\n *\r\n *  - If a column is resized, it should always use that width\r\n *\r\n *  - The proportional widths should never fall below min size if specified.\r\n *\r\n *  - If the grid starts off small but then becomes greater than the size ( + / - )\r\n *    the width should use the original width; not the newly proportioned widths.\r\n */\r\nfunction forceFillColumnWidths(allColumns, expectedWidth, startIdx, allowBleed, defaultColWidth) {\r\n    if (defaultColWidth === void 0) { defaultColWidth = 300; }\r\n    var columnsToResize = allColumns\r\n        .slice(startIdx + 1, allColumns.length)\r\n        .filter(function (c) {\r\n        return c.canAutoResize !== false;\r\n    });\r\n    for (var _i = 0, columnsToResize_1 = columnsToResize; _i < columnsToResize_1.length; _i++) {\r\n        var column = columnsToResize_1[_i];\r\n        if (!column.$$oldWidth) {\r\n            column.$$oldWidth = column.width;\r\n        }\r\n    }\r\n    var additionWidthPerColumn = 0;\r\n    var exceedsWindow = false;\r\n    var contentWidth = getContentWidth(allColumns, defaultColWidth);\r\n    var remainingWidth = expectedWidth - contentWidth;\r\n    var columnsProcessed = [];\r\n    // This loop takes care of the\r\n    do {\r\n        additionWidthPerColumn = remainingWidth / columnsToResize.length;\r\n        exceedsWindow = contentWidth >= expectedWidth;\r\n        for (var _a = 0, columnsToResize_2 = columnsToResize; _a < columnsToResize_2.length; _a++) {\r\n            var column = columnsToResize_2[_a];\r\n            if (exceedsWindow && allowBleed) {\r\n                column.width = column.$$oldWidth || column.width || defaultColWidth;\r\n            }\r\n            else {\r\n                var newSize = (column.width || defaultColWidth) + additionWidthPerColumn;\r\n                if (column.minWidth && newSize < column.minWidth) {\r\n                    column.width = column.minWidth;\r\n                    columnsProcessed.push(column);\r\n                }\r\n                else if (column.maxWidth && newSize > column.maxWidth) {\r\n                    column.width = column.maxWidth;\r\n                    columnsProcessed.push(column);\r\n                }\r\n                else {\r\n                    column.width = newSize;\r\n                }\r\n            }\r\n            column.width = Math.max(0, column.width);\r\n        }\r\n        contentWidth = getContentWidth(allColumns);\r\n        remainingWidth = expectedWidth - contentWidth;\r\n        removeProcessedColumns(columnsToResize, columnsProcessed);\r\n    } while (remainingWidth > 0 && columnsToResize.length !== 0);\r\n}\r\nexports.forceFillColumnWidths = forceFillColumnWidths;\r\n/**\r\n * Remove the processed columns from the current active columns.\r\n */\r\nfunction removeProcessedColumns(columnsToResize, columnsProcessed) {\r\n    for (var _i = 0, columnsProcessed_1 = columnsProcessed; _i < columnsProcessed_1.length; _i++) {\r\n        var column = columnsProcessed_1[_i];\r\n        var index = columnsToResize.indexOf(column);\r\n        columnsToResize.splice(index, 1);\r\n    }\r\n}\r\n/**\r\n * Gets the width of the columns\r\n */\r\nfunction getContentWidth(allColumns, defaultColWidth) {\r\n    if (defaultColWidth === void 0) { defaultColWidth = 300; }\r\n    var contentWidth = 0;\r\n    for (var _i = 0, allColumns_1 = allColumns; _i < allColumns_1.length; _i++) {\r\n        var column = allColumns_1[_i];\r\n        contentWidth += (column.width || defaultColWidth);\r\n    }\r\n    return contentWidth;\r\n}\r\n//# sourceMappingURL=math.js.map",null]}