import { Component, ElementRef, Input, Output, ChangeDetectionStrategy, ChangeDetectorRef, ViewChild, EventEmitter, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/** @enum {number} */
const ImageResolution = {
    /** Resizing & cropping */
    Default: 0,
    /** Only cropping */
    OriginalImage: 1,
};
ImageResolution[ImageResolution.Default] = "Default";
ImageResolution[ImageResolution.OriginalImage] = "OriginalImage";
/**
 * @record
 */

/**
 * @record
 */

const CONFIG_DEFAULT = /** @type {?} */ ({
    width: 250,
    height: 200,
    output: ImageResolution.Default
});
class LyResizingCroppingImages {
    /**
     * @param {?} elementRef
     * @param {?} cd
     */
    constructor(elementRef, cd) {
        this.elementRef = elementRef;
        this.cd = cd;
        this.img = new BehaviorSubject(null);
        this._src = new BehaviorSubject(null);
        this.config = CONFIG_DEFAULT;
        /**
         * On loaded new image
         */
        this.loaded = new EventEmitter();
        /**
         * On crop new image
         */
        this.cropped = new EventEmitter();
        /**
         * On error new image
         */
        this.error = new EventEmitter();
        this._dragData = new Subject();
        this.zoomScale = .1;
        this.dragData = this._dragData.asObservable();
        const /** @type {?} */ img = this.img;
        img.subscribe((imgElement) => {
            if (imgElement) {
                this._img = imgElement;
                /**
                 * set zoom scale
                 */
                const /** @type {?} */ minScale = {
                    width: this.config.width / this._img.width * 100,
                    height: this.config.height / this._img.height * 100
                };
                this.zoomScale = Math.max(minScale.width, minScale.height) / 100;
                this.fit();
                this.cd.markForCheck();
            }
        });
    }
    /**
     * @param {?} img
     * @return {?}
     */
    selectInputEvent(img) {
        const /** @type {?} */ _img = /** @type {?} */ (img.target);
        if (_img.files.length !== 1) {
            return;
        }
        const /** @type {?} */ fileReader = new FileReader();
        this.fileName = _img.value.replace(/.*(\/|\\)/, '');
        /** Set type */
        this.defaultType = null;
        if (!this.config.type) {
            this.defaultType = _img.files[0].type;
        }
        this.isLoaded = false;
        this.isCropped = false;
        this._dragData.next(null);
        fileReader.addEventListener('loadend', (loadEvent) => {
            const /** @type {?} */ originalImageUrl = (/** @type {?} */ (loadEvent.target)).result;
            this.setImageUrl(originalImageUrl);
            this.cd.markForCheck();
        });
        fileReader.readAsDataURL(_img.files[0]);
    }
    /**
     * @param {?} num
     * @return {?}
     */
    fixedNum(num) {
        return parseFloat(num.toFixed(0));
    }
    /**
     * @param {?} size
     * @return {?}
     */
    setScale(size) {
        console.log('setScale', size);
        // if (!(size > 0 && size <= 1)) { return; }
        this.scale = size;
        size = size * 100;
        const /** @type {?} */ img = this.imgContainer.nativeElement.firstElementChild;
        const /** @type {?} */ initialImg = this._img;
        const /** @type {?} */ width = this.fixedNum(initialImg.width * size / 100);
        const /** @type {?} */ height = this.fixedNum(initialImg.height * size / 100);
        this._dragData.next({
            width: `${width}px`,
            height: `${height}px`,
            transform: this.customCenter(width, height)
        });
    }
    /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    customCenter(width, height) {
        const /** @type {?} */ root = /** @type {?} */ (this.elementRef.nativeElement);
        const /** @type {?} */ w = (root.offsetWidth - width) / 2;
        const /** @type {?} */ h = (root.offsetHeight - height) / 2;
        return `translate3d(${w}px, ${h}px, 0)`;
    }
    /**
     * @return {?}
     */
    '1:1'() {
        this.setScale(1);
    }
    /**
     * Ajustar a la pantalla
     * @return {?}
     */
    fitToScreen() {
        const /** @type {?} */ container = /** @type {?} */ (this.elementRef.nativeElement);
        const /** @type {?} */ min = {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
        const /** @type {?} */ size = {
            width: this._img.width,
            height: this._img.height
        };
        const /** @type {?} */ minScale = {
            width: min.width / size.width * 100,
            height: min.height / size.height * 100
        };
        const /** @type {?} */ result = Math.max(minScale.width, minScale.height) / 100;
        // if (result >= 1) {
        // this.setScale(1);
        // } else {
        this.setScale(result);
        // }
    }
    /**
     * @return {?}
     */
    fit() {
        const /** @type {?} */ minScale = {
            width: this.config.width / this._img.width * 100,
            height: this.config.height / this._img.height * 100
        };
        this.setScale(Math.max(minScale.width, minScale.height) / 100);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _moveStart(event) {
        this.eventDirection = null;
        const /** @type {?} */ rect = this.imgContainer.nativeElement.getBoundingClientRect();
        const /** @type {?} */ hostRect = this.elementRef.nativeElement.getBoundingClientRect();
        let /** @type {?} */ target;
        if (event.type === 'touchstart') {
            target = {
                x: event.targetTouches[0].clientX,
                y: event.targetTouches[0].clientY
            };
        }
        else {
            target = {
                x: event.clientX,
                y: event.clientY
            };
        }
        this.offset = {
            x: target.x - rect.x,
            y: target.y - rect.y,
            left: (/** @type {?} */ (rect)).left - hostRect.x,
            top: (/** @type {?} */ (rect)).top - hostRect.y
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _move(event) {
        if (event.additionalEvent) {
            this.eventDirection = event.additionalEvent;
        }
        let /** @type {?} */ x, /** @type {?} */ y;
        const /** @type {?} */ hostRect = this.elementRef.nativeElement.getBoundingClientRect();
        const /** @type {?} */ rect = this.imgContainer.nativeElement.getBoundingClientRect();
        if (event.srcEvent.shiftKey) {
            // if (this.eventDirection === 'panleft' || this.eventDirection === 'panright') {
            if (Math.abs(event.deltaX) === Math.max(Math.abs(event.deltaX), Math.abs(event.deltaY))) {
                y = this.offset.top;
            }
            else {
                x = this.offset.left;
            }
        }
        if (x === undefined) {
            x = event.center.x - hostRect.x - (this.offset.x);
        }
        if (y === undefined) {
            y = event.center.y - hostRect.y - (this.offset.y);
        }
        this._dragData.next({
            width: this.imgContainer.nativeElement.offsetWidth,
            height: this.imgContainer.nativeElement.offsetHeight,
            transform: `translate3d(${x}px, ${y}px, 0)`
        });
    }
    /**
     * @param {?} num
     * @return {?}
     */
    roundNumber(num) {
        return Math.round(num * 100000) / 100000;
    }
    /**
     * +
     * @return {?}
     */
    zoomIn() {
        // const scale = this.roundNumber(this.scale + this.zoomScale);
        const /** @type {?} */ scale = this.roundNumber(this.scale + .05);
        if (scale > 0 && scale <= 1) {
            this.setScale(scale);
        }
        else {
            this.setScale(1);
        }
    }
    /**
     * -
     * @return {?}
     */
    zoomOut() {
        // const scale = this.roundNumber(this.scale - this.zoomScale);
        const /** @type {?} */ scale = this.roundNumber(this.scale - .05);
        if (scale > this.zoomScale && scale <= 1) {
            this.setScale(scale);
        }
        else {
            this.fit();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setImageUrl(this.src);
    }
    /**
     * @param {?=} img
     * @return {?}
     */
    center(img) {
        if (!img) {
            img = this.imgContainer.nativeElement.firstElementChild;
        }
        const /** @type {?} */ root = /** @type {?} */ (this.elementRef.nativeElement);
        const /** @type {?} */ w = (root.offsetWidth - img.width) / 2;
        const /** @type {?} */ h = (root.offsetHeight - img.height) / 2;
        const /** @type {?} */ result = {
            width: `${img.width}px`,
            height: `${img.height}px`,
            transform: this.customCenter(img.width, img.height)
        };
        this._dragData.next(result);
    }
    /**
     * @param {?} src
     * @return {?}
     */
    setImageUrl(src) {
        this.src = src;
        if (!src) {
            return;
        }
        const /** @type {?} */ img = new Image;
        img.src = src;
        img.addEventListener('error', (err) => {
            this.error.emit(null);
        });
        img.addEventListener('load', () => {
            this.img.next(img);
            this.loaded.emit(null);
            this.isLoaded = true;
            this.cd.markForCheck();
        });
    }
    /**
     * @param {...?} values
     * @return {?}
     */
    max(...values) {
        return Math.max(...values);
    }
    /**
     * @param {?} img
     * @param {?} config
     * @param {?} quality
     * @return {?}
     */
    imageSmoothingQuality(img, config, quality) {
        /**
         * Calculate total number of steps needed
         */
        let /** @type {?} */ numSteps = Math.ceil(Math.log(this.max(img.width, img.height) / this.max(config.height, config.width)) / Math.log(2)) - 1;
        numSteps = numSteps <= 0 ? 0 : numSteps;
        /**
         * Array steps
         */
        const /** @type {?} */ steps = Array.from(Array(numSteps).keys());
        /**
         * Context
         */
        const /** @type {?} */ octx = img.getContext('2d');
        const /** @type {?} */ q = Math.pow(quality * 10, numSteps) / Math.pow(10, numSteps);
        /** If Steps => imageSmoothingQuality */
        if (numSteps) {
            /**
             * Set size
             */
            const /** @type {?} */ w = img.width * quality;
            const /** @type {?} */ h = img.height * quality;
            /** Only the new img is shown. */
            octx.globalCompositeOperation = 'copy';
            /** Steps */
            (/** @type {?} */ (steps)).forEach((a, b) => {
                octx.drawImage(img, 0, 0, w, h);
            });
        }
        /**
         * Step final
         * Resizing & cropping image
         */
        const /** @type {?} */ oc = document.createElement('canvas'), /** @type {?} */
        ctx = oc.getContext('2d');
        oc.width = config.width;
        oc.height = config.height;
        ctx.drawImage(img, 0, 0, img.width * (q), img.height * (q), 0, 0, oc.width, oc.height);
        return oc;
    }
    /**
     * Crop Image
     * Resizing & cropping image
     * @return {?}
     */
    crop() {
        return {
            base64Image: this.cropp(),
            type: this.defaultType || this.config.type
        };
    }
    /**
     * Deprecated, use crop() instead
     * @return {?}
     */
    cropp() {
        const /** @type {?} */ myConfig = Object.assign({}, CONFIG_DEFAULT, this.config);
        const /** @type {?} */ canvasElement = document.createElement('canvas');
        const /** @type {?} */ rect = /** @type {?} */ (this.croppingContainer.nativeElement.getBoundingClientRect());
        const /** @type {?} */ img = /** @type {?} */ (this.imgContainer.nativeElement.firstElementChild.getBoundingClientRect());
        const /** @type {?} */ left = (rect.left - img.left);
        const /** @type {?} */ top = (rect.top - img.top);
        const /** @type {?} */ config = {
            width: myConfig.width,
            height: myConfig.height
        };
        const /** @type {?} */ configCanvas = {
            width: this._img.width,
            height: this._img.height
        };
        canvasElement.width = config.width / this.scale;
        canvasElement.height = config.height / this.scale;
        const /** @type {?} */ ctx = canvasElement.getContext('2d');
        ctx.drawImage(this._img, -(left / this.scale), -(top / this.scale));
        let /** @type {?} */ result = canvasElement;
        if (myConfig.output === 0) {
            result = this.imageSmoothingQuality(result, config, 0.5);
        }
        else if (typeof myConfig.output === 'object') {
            result = this.imageSmoothingQuality(result, myConfig.output, 0.5);
        }
        let /** @type {?} */ url;
        if (myConfig.type) {
            url = result.toDataURL(`image/${myConfig.type}`);
        }
        else {
            url = result.toDataURL(this.defaultType);
        }
        this.result = (url);
        this.cropped.emit({
            base64Image: url,
            type: this.defaultType || myConfig.type
        });
        this.isCropped = true;
        return url;
    }
}
LyResizingCroppingImages.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'ly-cropping',
                styles: [`:host{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:-webkit-box;display:-ms-flexbox;display:flex;overflow:hidden;position:relative;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ly-img-container{cursor:move;position:absolute;top:0;left:0}.ly-img-container img{width:100%;height:100%;pointer-events:none}.ly-cropping-container{z-index:11;position:absolute;pointer-events:none;-webkit-box-shadow:0 0 0 20000px rgba(0,0,0,.29);box-shadow:0 0 0 20000px rgba(0,0,0,.29)}.ly-cropping-container::after{content:'';position:absolute;top:0;left:0;right:0;bottom:0;border:2px solid #fff}.ly-cropp-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;position:absolute;top:0;left:0;right:0;bottom:0}.ly-cropp-content /deep/ :not(input){pointer-events:none}.ly-cropp-content input{position:absolute;background:0 0;opacity:0;top:0;left:0;right:0;bottom:0;width:100%;height:100%}`],
                template: `<div #_croppingContainer *ngIf="isLoaded; else content" class="ly-cropping-container" [ngStyle]="{
    width: config.width + 'px',
    height: config.height + 'px'
}"></div>
<div class="ly-img-container" #_imgContainer
(pan)="_move($event)"
(touchstart)="_moveStart($event)"
(mousedown)="_moveStart($event)"
[ngStyle]="dragData | async">
  <img *ngIf="isLoaded"
  [src]="src">
</div>
<ng-template #content>
  <div class="ly-cropp-content">
    <input #_fileInput type="file" (change)="selectInputEvent($event)" accept="image/*">
    <ng-content></ng-content>
  </div>
</ng-template>`,
            },] },
];
/** @nocollapse */
LyResizingCroppingImages.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
LyResizingCroppingImages.propDecorators = {
    "imgContainer": [{ type: ViewChild, args: ['_imgContainer',] },],
    "croppingContainer": [{ type: ViewChild, args: ['_croppingContainer',] },],
    "src": [{ type: Input },],
    "format": [{ type: Input },],
    "config": [{ type: Input },],
    "loaded": [{ type: Output },],
    "cropped": [{ type: Output },],
    "error": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyResizingCroppingImageModule {
}
LyResizingCroppingImageModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: [LyResizingCroppingImages],
                declarations: [LyResizingCroppingImages]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { ImageResolution, LyResizingCroppingImages, LyResizingCroppingImageModule };
//# sourceMappingURL=alyle-ui-resizing-cropping-images.js.map
