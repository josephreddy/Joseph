import { Renderer2, ElementRef } from '@angular/core';
import { ThemeVariables } from './alyle-config-service';
import { LyRootService } from './root.service';
export declare class LyTheme {
    private isRoot;
    private document;
    private rootService;
    renderer: Renderer2;
    Id: string;
    private themeContainer;
    themeName: string;
    _styleMap: Map<string, StyleData>;
    AlyleUI: {
        currentTheme: ThemeVariables;
        palette: any;
    };
    palette: ThemeVariables;
    /** get class name of color */
    getClassKey(color: string, of: 'color' | 'bg'): string;
    constructor(config: ThemeVariables, isRoot: boolean, document: any, rootService: LyRootService);
    setScheme(scheme: string): void;
    /**
     * get color of `string` in palette
     * @param value
     */
    colorOf(value: string): string;
    private getColorv2(colorName, colors, shade?);
    /**
     * @TODO: Importante!!
     * add extra Option for setStyle
     * for :hover, :focus, etc
     * esto solo creara el style, esto deve funcionar asi: ya no deve ser necesario agregar
     * con updateClassName
     * o crear nuevo estilo con el mismo id si existe extraOption, o crear una propiedad para eso
     * ejemplo:
     * addExtraOption('button', ':hover', myStyle) as void
     * addExtraOption(key: string, extra: string, style: () => string) {
     *   ...
     * }
     */
    /**
     * Create new style if not exist, for Theme
     * @param key unique id
     * @param fn style
     */
    setStyle(key: string, fn: () => string): string;
    /**
     * Create new style if not exist, for Root
     * Important: this not update when change theme
     * @param key unique id
     * @param fn style
     */
    setRootStyle(key: string, fn: () => string): string;
    private _createStyle(key, newKey, fn, mapStyles, _for);
    /** #style */
    private createStyleContent(styleData);
    /** Update style of StyleData */
    private updateStyleValue(style, styleText);
    /** #style: Update all styles */
    private updateOthersStyles();
    /** Replace old class by newClass */
    updateClass(elementRef: ElementRef, renderer: Renderer2, newStyleData: StyleData, oldStyleData?: StyleData): void;
    /** Replace old class by newClass */
    updateClassName(element: any, renderer: Renderer2, newClassname: string, oldClassname?: string): void;
    private setCoreStyle();
}
export interface StyleData {
    /** Class Id */
    id: string;
    key: string;
    styleContainer: any;
    styleContent: any;
    fn: () => string;
}
export declare function mergeDeep(...objects: any[]): any;
export declare function parsePalette(palette: {
    [key: string]: any;
}): any;
