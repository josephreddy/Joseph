import { InjectionToken, Injectable, Inject, RendererFactory2, NgModule, Directive, Input, Optional, Renderer2, ElementRef, ViewContainerRef, Output, EventEmitter, ComponentFactoryResolver, SkipSelf, ChangeDetectorRef, NgZone, defineInjectable, inject } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as _chroma from 'chroma-js';
import { Subject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} hexcolor
 * @return {?}
 */
function getContrastYIQ(hexcolor) {
    const /** @type {?} */ r = parseInt(hexcolor.substr(0, 2), 16);
    const /** @type {?} */ g = parseInt(hexcolor.substr(2, 2), 16);
    const /** @type {?} */ b = parseInt(hexcolor.substr(4, 2), 16);
    const /** @type {?} */ yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? 'black' : 'white';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const contrast = '#fff';
const defaultTheme = {
    name: 'default',
    primary: {
        default: '#2196F3',
        contrast
    },
    accent: {
        default: '#ff4b73',
        contrast
    },
    warn: {
        default: '#FF5252',
        contrast
    },
    scheme: 'light',
    typography: {
        fontFamily: `'Roboto', sans-serif`,
        fontSize: 14
    },
    colorSchemes: {
        light: {
            background: {
                default: '#fafafa',
                // secondary
                primary: '#fff',
                secondary: '#fafafa',
                tertiary: '#f5f5f5',
                base: '#E0E0E0'
            },
            text: {
                default: 'rgba(0, 0, 0, 0.87)',
                primary: 'rgba(0, 0, 0, 0.87)',
                secondary: 'rgba(0, 0, 0, 0.54)',
                disabled: 'rgba(0, 0, 0, 0.38)',
                hint: 'rgba(0, 0, 0, 0.38)'
            },
            divider: 'rgba(0, 0, 0, 0.12)',
            colorShadow: '#777777',
            /** Components variables */
            button: {
                disabled: 'rgba(0, 0, 0, 0.11)'
            },
            radio: {
                radioOuterCircle: 'rgba(0, 0, 0, 0.43)'
            },
            menu: {
                bg: '#fff' // background>primary
            },
            drawer: {
                backdrop: 'rgba(0,0,0,.6)'
            },
            bar: '#f5f5f5',
            input: {
                label: 'rgba(0, 0, 0, 0.4)',
                underline: 'rgba(0, 0, 0, 0.11)'
            },
        },
        dark: {
            primary: {
                default: '#9c27b0',
                contrast
            },
            accent: {
                default: '#ffeb3b',
                contrast: 'rgba(0, 0, 0, 0.87)'
            },
            warn: {
                default: '#f44336',
                contrast: 'rgba(0, 0, 0, 0.87)'
            },
            background: {
                default: '#303030',
                // secondary
                primary: '#424242',
                secondary: '#303030',
                tertiary: '#212121',
                base: '#0E0E0E'
            },
            text: {
                default: '#fff',
                primary: '#fff',
                secondary: 'rgba(255, 255, 255, 0.70)',
                disabled: 'rgba(255, 255, 255, 0.50)',
                hint: 'rgba(255, 255, 255, 0.50)'
            },
            /** Components variables */
            button: {
                disabled: 'rgba(255, 255, 255, 0.30)'
            },
            radio: {
                radioOuterCircle: 'rgba(255, 255, 255, 0.55)'
            },
            menu: {
                bg: '#424242' // background>primary
            },
            drawer: {
                backdrop: 'rgba(49,49,49,.6)'
            },
            bar: '#212121',
            divider: 'rgba(255, 255, 255, 0.12)',
            colorShadow: 'rgba(0, 0, 0, 1)',
            input: {
                label: 'rgba(255, 255, 255, 0.4)',
                underline: 'rgba(255, 255, 255, 0.11)'
            }
        }
    },
    iconButton: {
        size: '48px'
    },
    icon: {
        fontSize: '24px'
    },
    input: {
        /** default color */
        withColor: 'primary'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const THEME_VARIABLES = new InjectionToken('ly.theme.variables');
const IS_CORE_THEME = new InjectionToken('ly.is.root');
class StyleMap {
    /**
     * @param {?} themeName
     */
    constructor(themeName) {
        this.themeName = themeName;
    }
}
/**
 * @record
 */

class ThemeVariables {
}
/**
 * @record
 */

/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Whether the current platform supports the V8 Break Iterator. The V8 check
// is necessary to detect all Blink based browsers.
const hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);
/**
 * Service to detect the current platform by comparing the userAgent strings and
 * checking browser-specific global properties.
 */
class Platform {
    constructor() {
        /**
         * Layout Engines
         */
        this.EDGE = Platform.isBrowser && /(edge)/i.test(navigator.userAgent);
        this.TRIDENT = Platform.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
        this.BLINK = Platform.isBrowser &&
            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);
        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
        // ensure that Webkit runs standalone and is not used as another engine's base.
        this.WEBKIT = Platform.isBrowser &&
            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
        /**
         * Browsers and Platform Types
         */
        this.IOS = Platform.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !(/** @type {?} */ (window)).MSStream;
        // It's difficult to detect the plain Gecko engine, because most of the browsers identify
        // them self as Gecko-like browsers and modify the userAgent's according to that.
        // Since we only cover one explicit Firefox case, we can simply check for Firefox
        // instead of having an unstable check for Gecko.
        this.FIREFOX = Platform.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
        // Trident on mobile adds the android platform to the userAgent to trick detections.
        this.ANDROID = Platform.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
        // Safari browser should also use Webkit as its layout engine.
        this.SAFARI = Platform.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
    }
}
Platform.isBrowser = typeof document === 'object' && !!document;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyRootService {
    /**
     * @param {?} _document
     * @param {?} rendererFactory
     */
    constructor(_document, rendererFactory) {
        this.rendererFactory = rendererFactory;
        this.themeRootMap = new Map();
        this.themeMap = new Map();
        this.themes = new Map();
        this.renderer = this.rendererFactory.createRenderer(null, null);
        let /** @type {?} */ container;
        if (Platform.isBrowser && (container = window.document.querySelector('ly-core-theme'))) {
            this.rootContainer = container;
        }
        else {
            this.rootContainer = this.renderer.createElement('ly-core-theme');
            this.renderer.insertBefore(_document.body, this.rootContainer, _document.body.firstElementChild);
        }
    }
    /**
     * @param {?} palette
     * @return {?}
     */
    registerTheme(palette) {
        if (!this.themeMap.has(palette.name)) {
            this.themeMap.set(palette.name, new Map());
            this.themes.set(palette.name, palette);
        }
        return {
            map: this.themeMap.get(palette.name),
            palette: this.themes.get(palette.name)
        };
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getTheme(name) {
        return this.themes.get(name);
    }
}
LyRootService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
LyRootService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    { type: RendererFactory2, },
];
/** @nocollapse */ LyRootService.ngInjectableDef = defineInjectable({ factory: function LyRootService_Factory() { return new LyRootService(inject(DOCUMENT), inject(RendererFactory2)); }, token: LyRootService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
let classId = 0;
/**
 * Prefix for className
 */
let prefix;
if (Platform.isBrowser) {
    prefix = 'ly_';
}
else {
    prefix = 'l';
}
class LyTheme {
    /**
     * @param {?} config
     * @param {?} isRoot
     * @param {?} document
     * @param {?} rootService
     */
    constructor(config, isRoot, document, rootService) {
        this.isRoot = isRoot;
        this.document = document;
        this.rootService = rootService;
        const /** @type {?} */ newConfig = mergeDeep(defaultTheme, config);
        const /** @type {?} */ _palette = newConfig;
        const /** @type {?} */ theme = this.rootService.registerTheme(_palette);
        /** check if exist scheme */
        if (!theme.palette["colorSchemes"][theme.palette["scheme"]]) {
            throw new Error(`scheme ${theme.palette["scheme"]} not exist in ${theme.palette["name"]}`);
        }
        this._styleMap = theme.map;
        // Object.assign(this.palette, theme.palette, { scheme: config.scheme }, ...theme.palette.colorSchemes[newConfig.scheme]);
        this.palette = mergeDeep(theme.palette, { scheme: config.scheme }, ...theme.palette["colorSchemes"][newConfig.scheme]);
        this.themeName = newConfig.name;
        this.Id = `${this.themeName}`;
        this.setCoreStyle();
    }
    /**
     * get class name of color
     * @param {?} color
     * @param {?} of
     * @return {?}
     */
    getClassKey(color, of) {
        return `${this.Id}-${color.replace(':', '__')}-${of}`;
    }
    /**
     * @param {?} scheme
     * @return {?}
     */
    setScheme(scheme) {
        const /** @type {?} */ newPalette = this.rootService.getTheme(this.palette.name);
        this.palette = mergeDeep(newPalette, ...newPalette["colorSchemes"][scheme], { scheme });
        this.updateOthersStyles();
    }
    /**
     * get color of `string` in palette
     * @param {?} value
     * @return {?}
     */
    colorOf(value) {
        return get(this.palette, value);
    }
    /**
     * @param {?} colorName
     * @param {?} colors
     * @param {?=} shade
     * @return {?}
     */
    getColorv2(colorName, colors, shade) {
        const /** @type {?} */ ar = colors ? colors : this.palette;
        if (ar[colorName]) {
            if (typeof ar[colorName].color === 'string' || typeof ar[colorName] === 'string') {
                return ar[colorName].color || ar[colorName];
            }
            else {
                return ar[colorName].color[shade];
            }
        }
        else {
            return colorName;
        }
    }
    /**
     * Create new style if not exist, for Theme
     * @param {?} key unique id
     * @param {?} fn style
     * @return {?}
     */
    setStyle(key, fn) {
        const /** @type {?} */ newKey = createKeyOf(key + this.Id + this.palette.scheme);
        const /** @type {?} */ mapStyles = this._styleMap;
        return this._createStyle(key, newKey, fn, mapStyles, this.Id);
    }
    /**
     * Create new style if not exist, for Root
     * Important: this not update when change theme
     * @param {?} key unique id
     * @param {?} fn style
     * @return {?}
     */
    setRootStyle(key, fn) {
        const /** @type {?} */ newKey = createKeyOf(key);
        const /** @type {?} */ mapStyles = this.rootService.themeRootMap;
        return this._createStyle(key, newKey, fn, mapStyles, 'root');
    }
    /**
     * @param {?} key
     * @param {?} newKey
     * @param {?} fn
     * @param {?} mapStyles
     * @param {?} _for
     * @return {?}
     */
    _createStyle(key, newKey, fn, mapStyles, _for) {
        const /** @type {?} */ styleData = /** @type {?} */ ({ key: newKey, fn });
        if (mapStyles.has(newKey)) {
            return mapStyles.get(newKey).id;
        }
        else if (Platform.isBrowser && (styleData.styleContainer = this.document.body.querySelector(`ly-core-theme style[data-key="${newKey}"]`))) {
            styleData.styleContent = styleData.styleContainer.innerHTML;
            styleData.id = styleData.styleContainer.dataset.id;
        }
        else {
            classId++;
            styleData.id = `${prefix}${classId.toString(36)}`;
            styleData.styleContainer = this.rootService.renderer.createElement('style');
            const /** @type {?} */ content = this.createStyleContent(styleData);
            // if (isDevMode()) {
            //   content = `/** key: ${key}, for: ${_for} */\n${content}`;
            // }
            styleData.styleContent = content;
            this.rootService.renderer.appendChild(styleData.styleContainer, styleData.styleContent);
            this.rootService.renderer.appendChild(this.rootService.rootContainer, styleData.styleContainer);
            if (!Platform.isBrowser) {
                this.rootService.renderer.setAttribute(styleData.styleContainer, `data-key`, `${newKey}`);
                this.rootService.renderer.setAttribute(styleData.styleContainer, `data-id`, `${styleData.id}`);
            }
        }
        mapStyles.set(newKey, styleData);
        return styleData.id;
    }
    /**
     * #style
     * @param {?} styleData
     * @return {?}
     */
    createStyleContent(styleData) {
        return this.rootService.renderer.createText(`.${styleData.id}{${styleData.fn()}}`);
    }
    /**
     * Update style of StyleData
     * @param {?} style
     * @param {?} styleText
     * @return {?}
     */
    updateStyleValue(style, styleText) {
        const /** @type {?} */ styleContent = styleText;
        this.rootService.renderer.removeChild(style.styleContainer, style.styleContent);
        this.rootService.renderer.appendChild(style.styleContainer, styleContent);
        this._styleMap.set(style.key, Object.assign({}, style, {
            styleContainer: style.styleContainer,
            styleContent
        }));
    }
    /**
     * #style: Update all styles
     * @return {?}
     */
    updateOthersStyles() {
        this._styleMap.forEach((styleData) => {
            const /** @type {?} */ newStyleValue = this.createStyleContent(styleData);
            this.updateStyleValue(styleData, newStyleValue);
        });
    }
    /**
     * Replace old class by newClass
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} newStyleData
     * @param {?=} oldStyleData
     * @return {?}
     */
    updateClass(elementRef, renderer, newStyleData, oldStyleData) {
        if (oldStyleData) {
            renderer.removeClass(elementRef.nativeElement, oldStyleData.id);
        }
        renderer.addClass(elementRef.nativeElement, newStyleData.id);
    }
    /**
     * Replace old class by newClass
     * @param {?} element
     * @param {?} renderer
     * @param {?} newClassname
     * @param {?=} oldClassname
     * @return {?}
     */
    updateClassName(element, renderer, newClassname, oldClassname) {
        if (oldClassname) {
            renderer.removeClass(element, oldClassname);
        }
        renderer.addClass(element, newClassname);
    }
    /**
     * @return {?}
     */
    setCoreStyle() {
        if (this.isRoot) {
            const /** @type {?} */ classname = this.setStyle('body', () => (`background-color:${this.palette["background"].primary};` +
                `color:${this.palette["text"].default};` +
                `font-family:${this.palette["typography"].fontFamily};` +
                `margin:0;`));
            this.rootService.renderer.addClass(this.document.body, classname);
        }
    }
}
LyTheme.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LyTheme.ctorParameters = () => [
    { type: ThemeVariables, decorators: [{ type: Inject, args: [THEME_VARIABLES,] },] },
    { type: undefined, decorators: [{ type: Inject, args: [IS_CORE_THEME,] },] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    { type: LyRootService, },
];
/**
 * @record
 */

/**
 * @param {...?} objects
 * @return {?}
 */
function mergeDeep(...objects) {
    // const output = Object.assign({}, target);
    // if (isObject(target) && isObject(source)) {
    //   Object.keys(source).forEach(key => {
    //     if (isObject(source[key])) {
    //       if (!(key in target)) {
    //         Object.assign(output, { [key]: source[key] });
    //       } else {
    //         output[key] = mergeDeep(target[key], source[key]);
    //       }
    //     } else {
    //       Object.assign(output, { [key]: source[key] });
    //     }
    //   });
    // }
    // return output;
    const /** @type {?} */ isObject = obj => obj && typeof obj === 'object';
    return objects.reduce((prev, obj) => {
        Object.keys(obj).forEach(key => {
            const /** @type {?} */ pVal = prev[key];
            const /** @type {?} */ oVal = obj[key];
            if (Array.isArray(pVal) && Array.isArray(oVal)) {
                prev[key] = pVal.concat(...oVal);
            }
            else if (isObject(pVal) && isObject(oVal)) {
                prev[key] = mergeDeep(pVal, oVal);
            }
            else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, {});
}
/**
 * @param {?} palette
 * @return {?}
 */
function parsePalette(palette) {
    const /** @type {?} */ iterate = (obj, keyObject) => {
        for (const /** @type {?} */ key in obj) {
            if (obj.hasOwnProperty(key)) {
                const /** @type {?} */ key$ = keyObject ? `${keyObject}__${key}` : key;
                if (obj[key] !== null &&
                    typeof obj[key] === 'string' &&
                    key !== 'default') {
                    obj[key] = { default: obj[key] };
                }
                if (typeof obj[key] === 'object') {
                    iterate(obj[key], key$);
                }
            }
        }
        return obj;
    };
    return iterate(Object.assign({}, palette));
}
/**
 * @param {?} str
 * @return {?}
 */
function createKeyOf(str) {
    // return str.split('').map((char) => {
    //     return char.charCodeAt(0).toString(36);
    // }).join('');
    let /** @type {?} */ hash = 0;
    const /** @type {?} */ len = str.length;
    for (let /** @type {?} */ i = 0; i < len; i++) {
        // tslint:disable-next-line:no-bitwise
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        // tslint:disable-next-line:no-bitwise
        hash |= 0; // to 32bit integer
    }
    return hash.toString(36);
}
/**
 * @param {?} obj
 * @param {?} path
 * @return {?}
 */
function get(obj, path) {
    const /** @type {?} */ _path = path instanceof Array ? path : path.split(':');
    for (let /** @type {?} */ i = 0; i < _path.length; i++) {
        obj = obj[_path[i]] || path;
    }
    return typeof obj === 'string' ? /** @type {?} */ (obj) : /** @type {?} */ (obj['default']);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const chroma = _chroma;
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
const elevations = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 3, 0, 0, 1, 1, 0, 0, 2, 1, -1],
    [0, 1, 5, 0, 0, 2, 2, 0, 0, 3, 1, -2],
    [0, 1, 8, 0, 0, 3, 4, 0, 0, 3, 3, -2],
    [0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0],
    [0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0],
    [0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0],
    [0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1],
    [0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2],
    [0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2],
    [0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3],
    [0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3],
    [0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4],
    [0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4],
    [0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4],
    [0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5],
    [0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5],
    [0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5],
    [0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6],
    [0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6],
    [0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7],
    [0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7],
    [0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7],
    [0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8],
    [0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8]
];
/**
 * @param {?=} elevation
 * @param {?=} color
 * @return {?}
 */
function shadowBuilder(elevation = 1, color = '#000') {
    const /** @type {?} */ Color = chroma(color);
    const /** @type {?} */ colors = [
        Color.alpha(shadowKeyUmbraOpacity).css(),
        Color.alpha(shadowKeyPenumbraOpacity).css(),
        Color.alpha(shadowAmbientShadowOpacity).css()
    ];
    const /** @type {?} */ e = elevations[elevation];
    // tslint:disable-next-line:max-line-length
    return `box-shadow:${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px ${colors[0]},${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px ${colors[1]},${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px ${colors[2]};`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RandomId {
    /**
     * @return {?}
     */
    get generate() {
        const /** @type {?} */ id = (Math.random() + Date.now());
        return id;
    }
}
RandomId.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} el
 * @param {?} parentSelector
 * @return {?}
 */
function getParents(el, parentSelector) {
    // If no parentSelector defined will bubble up all the way to *document*
    if (parentSelector === undefined) {
        parentSelector = 'body';
    }
    const /** @type {?} */ parents = [];
    let /** @type {?} */ p = el.parentNode;
    let /** @type {?} */ pxz = null;
    while (!pxz) {
        const /** @type {?} */ o = p;
        parents.push(o);
        p = o.parentNode;
        pxz = p.querySelector(parentSelector);
    }
    // parents.push(_parentSelector); // Push that parentSelector you wanted to stop at
    // console.log(parents[parents.length - 1]);
    return parents[parents.length - 1];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Color tranformation
 * @param {?} intInput
 * @return {?}
 */
function getHexValue(intInput) {
    let /** @type {?} */ result = intInput.toString(16);
    if (result.length < 2) {
        result = '0' + result;
    }
    return result;
}
/**
 * @param {?} red
 * @param {?} green
 * @param {?} blue
 * @param {?=} alpha
 * @return {?}
 */
function Color(red, green, blue, alpha) {
    return {
        red: red,
        green: green,
        blue: blue,
        alpha: alpha,
        toHex: () => {
            return getHexValue(red) + getHexValue(green) + getHexValue(blue);
        }
    };
}
const ɵ0 = function (color, bgColor) {
    const /** @type {?} */ alpha = color.alpha;
    /**
     * @param {?} tint
     * @param {?} bgTint
     * @return {?}
     */
    function getTintValue(tint, bgTint) {
        const /** @type {?} */ tmp = Math.floor((1 - alpha) * bgTint + alpha * tint);
        if (tmp > 255) {
            return 255;
        }
        return tmp;
    }
    return Color(getTintValue(color.red, bgColor.red), getTintValue(color.green, bgColor.green), getTintValue(color.blue, bgColor.blue));
};
// Converter which actually does the calculation from rgba to hex.
const colorConverter = {
    // Converts the given color to a Color object, using the given gbColor in the calculation.
    convertToHex: ɵ0
};
/**
 * @param {?} p
 * @param {?} q
 * @param {?} t
 * @return {?}
 */
function hue2rgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}
const ɵ1 = function (rgba) {
    // Strip the rgba-definition off the string.
    rgba = rgba.replace('rgba(', '')
        .replace(')', '')
        .replace(' ', '');
    // Split the rgba string into an array.
    const /** @type {?} */ splittedRgba = rgba.split(',');
    return Color(parseInt(splittedRgba[0], 10), parseInt(splittedRgba[1], 10), parseInt(splittedRgba[2], 10), parseFloat(splittedRgba[3]) || 1);
};
const ɵ2 = function (hexString) {
    hexString = hexString.replace('#', '');
    let /** @type {?} */ rgbArr = [];
    /**
     * @param {?} index
     * @return {?}
     */
    function getHexPartByIndex(index) {
        switch (hexString.length) {
            case 3:
                return hexString[index] + hexString[index];
            default:
                index *= 2;
                return hexString[index] + hexString[index + 1];
        }
    }
    // String the "#" off the hex-string.
    hexString = hexString.replace('#', '');
    // Convert pairs of hex-characters into decimal numbers.
    for (let /** @type {?} */ i = 0; i < hexString.length; i++) {
        rgbArr.push(parseInt(getHexPartByIndex(i), 16));
    }
    return Color(rgbArr[0], rgbArr[1], rgbArr[2], 1);
};
const ɵ3 = function hslToRgb(hsla) {
    hsla = hsla.replace('hsla(', '')
        .replace('hsl(', '')
        .replace(')', '')
        .replace(' ', '');
    // Split the hsla string into an array.
    hsla = hsla.split(',');
    const /** @type {?} */ h = parseInt(hsla[0], 10) / 360;
    const /** @type {?} */ s = parseInt(hsla[1], 10) / 100;
    const /** @type {?} */ l = parseInt(hsla[2], 10) / 100;
    const /** @type {?} */ a = parseFloat(hsla[3]) || 1;
    let /** @type {?} */ r, /** @type {?} */ g, /** @type {?} */ b;
    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        const /** @type {?} */ q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const /** @type {?} */ p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return Color(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
};
const colorStringParser = {
    // Converter for rgb(a) colors
    rgba: ɵ1,
    // Converter for hex colors
    hex: ɵ2,
    // Converter for hsl(a) colors.
    hsla: ɵ3
};
/**
 * @param {?} colorString
 * @return {?}
 */
function getColorType(colorString) {
    if (colorString.indexOf('rgba') !== -1 || colorString.indexOf('rgb') !== -1) {
        return 'rgba';
    }
    if (colorString.indexOf('hsla') !== -1 || colorString.indexOf('hsl') !== -1) {
        return 'hsla';
    }
    return 'hex';
}
/**
 * @param {?} inputString
 * @return {?}
 */
function getColorForString(inputString) {
    return colorStringParser[getColorType(inputString)](inputString);
}
/**
 * @param {?} str
 * @return {?}
 */
function trim(str) {
    return str.replace(/^\s+|\s+$/gm, '');
}
/**
 * @param {?} rgba
 * @return {?}
 */
function rgbaToHex(rgba) {
    const /** @type {?} */ parts = rgba.substring(rgba.indexOf('(')).split(','), /** @type {?} */
    r = parseInt(trim(parts[0].substring(1)), 10), /** @type {?} */
    g = parseInt(trim(parts[1]), 10), /** @type {?} */
    b = parseInt(trim(parts[2]), 10), /** @type {?} */
    a = parseFloat(trim(parts[3].substring(0, parts[3].length - 1))).toFixed(2);
    return ('#' + r.toString(16) + g.toString(16) + b.toString(16) + (Number(a) * 255).toString(16).substring(0, 2));
}
/**
 * @param {?} c
 * @return {?}
 */
function componentToHex(c) {
    c = Number(c);
    const /** @type {?} */ hex = c.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
}
/**
 * @param {?} str
 * @param {?=} alpha
 * @return {?}
 */
function toRgb(str, alpha) {
    return hexToRgba(colorConverter.convertToHex(getColorForString(str), getColorForString('#ffffff')).toHex(), alpha || 1);
}
/**
 * @param {?} str
 * @return {?}
 */
function converterToHex(str) {
    return colorConverter.convertToHex(getColorForString(str), getColorForString('#ffffff')).toHex();
}
/**
 * @param {?} rgb
 * @return {?}
 */
function rgbToHex(rgb) {
    let /** @type {?} */ toRgb = rgb;
    if (toRgb.substr(0, 4) === 'rgba') {
        toRgb = toRgb.slice(5);
    }
    else {
        toRgb = toRgb.slice(4);
    }
    toRgb = toRgb.slice(0, -1);
    toRgb = toRgb.replace(' ', '');
    toRgb = toRgb.split(',');
    return componentToHex(toRgb[0]) + componentToHex(toRgb[1]) + componentToHex(toRgb[2]);
}
/**
 * @param {?} rgba
 * @return {?}
 */
function rgbTransparent(rgba) {
    if (typeof rgba === 'string') {
        rgba = rgba.slice(0, -1);
        rgba = (rgba.split(',')[3]) * 1;
        if (typeof rgba === 'number') {
            rgba = 1;
        }
    }
    else {
        rgba = 1;
    }
    return rgba;
}
/**
 * @param {?} hex
 * @param {?=} tr
 * @return {?}
 */
function hexToRgba(hex, tr = -1) {
    const /** @type {?} */ _default = hex;
    const /** @type {?} */ transparent = {
        r: 0,
        g: 0,
        b: 0,
        a: 0
    };
    if (tr === -1) {
        tr = rgbTransparent(hex);
    }
    hex = String(hex);
    if ((hex.substr(0, 4) === 'rgba') && !!hex.split(',')[3]) {
        tr = parseFloat(hex.split(',')[3].replace(')', ''));
        hex = String(hex);
        if (hex.length !== 6 && hex.length !== 3) {
            hex = rgbToHex(hex);
        }
    }
    if (hex !== undefined && hex !== null && hex !== 'transparent') {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const /** @type {?} */ shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => {
            return r + r + g + g + b + b;
        });
        const /** @type {?} */ result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        let /** @type {?} */ colorr = 0;
        let /** @type {?} */ colorg = 0;
        let /** @type {?} */ colorb = 0;
        if (result) {
            colorr = parseInt(result[1], 16);
            colorg = parseInt(result[2], 16);
            colorb = parseInt(result[3], 16);
        }
        return result ? {
            json: {
                r: colorr,
                g: colorg,
                b: colorb,
                a: tr
            },
            color: `rgba(${colorr}, ${colorg}, ${colorb}, ${tr})`,
        } : {
            json: transparent,
            color: `${_default}`,
        };
    }
    else {
        return {
            json: transparent,
            color: `rgba(${0}, ${0}, ${0}, ${0})`,
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const LY_GLOBAL_CONTRAST = new InjectionToken('ly.global.contrast');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NgTranscludeDirective {
    /**
     * @param {?} _viewRef
     */
    constructor(_viewRef) {
        this._viewRef = _viewRef;
        this.ngTranscludeChange = new EventEmitter();
        this.viewRef = _viewRef;
    }
    /**
     * @param {?} templateRef
     * @return {?}
     */
    set ngTransclude(templateRef) {
        this._ngTransclude = templateRef;
        if (templateRef) {
            this.viewRef.createEmbeddedView(templateRef);
        }
    }
    /**
     * @return {?}
     */
    get ngTransclude() {
        return this._ngTransclude;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.ngTranscludeChange.emit(true);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.viewRef.detach();
    }
}
NgTranscludeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngTransclude]'
            },] },
];
/** @nocollapse */
NgTranscludeDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
NgTranscludeDirective.propDecorators = {
    "ngTransclude": [{ type: Input },],
    "ngTranscludeChange": [{ type: Output },],
};
class NgTranscludeModule {
}
NgTranscludeModule.decorators = [
    { type: NgModule, args: [{
                exports: [NgTranscludeDirective],
                declarations: [NgTranscludeDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isWindow(obj) {
    return obj !== null && obj === obj.window;
}
/**
 * @param {?} elem
 * @return {?}
 */
function getWindow(elem) {
    return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
}
/**
 * @param {?} elem
 * @return {?}
 */
function exactPosition(elem) {
    let /** @type {?} */ docElem, /** @type {?} */ win, /** @type {?} */
    box = { top: 0, left: 0 };
    const /** @type {?} */ doc = elem && elem.ownerDocument;
    docElem = doc.documentElement;
    if (typeof elem.getBoundingClientRect !== typeof undefined) {
        box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function toBoolean(value) {
    return value != null && `${value}` !== 'false';
}
/**
 * @deprecated
 * @return {?}
 */
function IsBoolean() {
    return (target, key) => {
        const /** @type {?} */ definition = Object.getOwnPropertyDescriptor(target, key);
        if (definition) {
            Object.defineProperty(target, key, {
                get: definition.get,
                set: newValue => {
                    definition.set(toBoolean(newValue));
                },
                enumerable: true,
                configurable: true
            });
        }
        else {
            Object.defineProperty(target, key, {
                get: function () {
                    return this['__' + key];
                },
                set: function (newValue) {
                    this['__' + key] = toBoolean(newValue);
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} theme
 * @return {?}
 */
function provideTheme(theme) {
    return [
        [LyTheme],
        { provide: THEME_VARIABLES, useValue: theme },
    ];
}
class AlyleUIModule {
    /**
     * Set a theme for core
     * @param {?} theme
     * @return {?}
     */
    static forRoot(theme) {
        return {
            ngModule: AlyleUIModule,
            providers: [
                provideTheme(theme),
                { provide: IS_CORE_THEME, useValue: true },
            ]
        };
    }
    /**
     * Set a theme for this module
     * @param {?} theme
     * @return {?}
     */
    static forChild(theme) {
        return {
            ngModule: AlyleUIModule,
            providers: [
                provideTheme(theme),
                { provide: IS_CORE_THEME, useValue: false }
            ]
        };
    }
}
AlyleUIModule.decorators = [
    { type: NgModule },
];
const ProvidedInTheme = {
    providedIn: AlyleUIModule
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyShadowService {
    /**
     * @param {?} theme
     */
    constructor(theme) {
        this.theme = theme;
        /**
         * Default elevation
         */
        this.elevation = 1;
    }
    /**
     * demo: setShadow(...[elevation, color]...)
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} val
     * @param {?=} oldClassName
     * @return {?}
     */
    setShadow(elementRef, renderer, val, oldClassName) {
        let /** @type {?} */ keys;
        let /** @type {?} */ elevation;
        let /** @type {?} */ color = 'colorShadow';
        if (val) {
            keys = val.join('');
            elevation = val[0];
            color = val[1] || color;
        }
        else {
            keys = `${this.elevation}${color}`;
            elevation = this.elevation;
        }
        const /** @type {?} */ classname = this.theme.setStyle(`shadow${keys}`, () => {
            return `${shadowBuilder(elevation, this.theme.colorOf(color))}`;
        });
        this.theme.updateClassName(elementRef.nativeElement, renderer, classname, oldClassName);
        return classname;
    }
}
LyShadowService.decorators = [
    { type: Injectable, args: [ProvidedInTheme,] },
];
/** @nocollapse */
LyShadowService.ctorParameters = () => [
    { type: LyTheme, },
];
/** @nocollapse */ LyShadowService.ngInjectableDef = defineInjectable({ factory: function LyShadowService_Factory() { return new LyShadowService(inject(LyTheme)); }, token: LyShadowService, providedIn: AlyleUIModule });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyBgColorAndRaised {
    /**
     * @param {?} theme
     * @param {?} renderer
     * @param {?} elementRef
     * @param {?} shadow
     * @param {?} contrast
     */
    constructor(theme, renderer, elementRef, shadow, contrast) {
        this.theme = theme;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.shadow = shadow;
        this.contrast = contrast;
        this.elevation = 3;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set bg(value) {
        this._bg = value;
        // this._cssBg = this.theme.colorOf(value);
    }
    /**
     * @return {?}
     */
    get bg() {
        return this._bg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set color(value) {
        this._color = value;
        // this._cssColor = this.theme.colorOf(value);
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set raised(val) { this._raisedState = toBoolean(val); }
    /**
     * @return {?}
     */
    get raised() { return this._raisedState; }
    /**
     * @return {?}
     */
    setAutoContrast() {
        this.contrast = true;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ newClassName;
        /**
         * ~
         */
        const /** @type {?} */ raisedĸey = this._raisedState === true ? 'raised' : '';
        let /** @type {?} */ key = '';
        if ((this.contrast && !this.color || this.color === 'auto') && this.bg) {
            key = `contrast${this.bg}${this._raisedState}${this.elevation}`;
            newClassName = this.theme.setStyle(`ly-${key}`, this.contrastStyle.bind(this));
        }
        else if (this.bg && this.color) {
            key = `b&ĸ${this.bg}${this.color}${this._raisedState}${this.elevation}`;
            newClassName = this.theme.setStyle(`ly-${key}`, this.bgColorStyle.bind(this));
        }
        else if (this.raised && !this.bg) {
            key = raisedĸey + this.color || '';
            newClassName = this.theme.setStyle(`ly-${key}`, () => {
                let /** @type {?} */ styles = `background-color:${this.theme.palette["background"].primary};`;
                let /** @type {?} */ color = '';
                let /** @type {?} */ colorShadow;
                if (this.color) {
                    color = this.theme.colorOf(this.color);
                    colorShadow = color;
                    styles += `color:${color};`;
                }
                else {
                    colorShadow = this.theme.palette["colorShadow"];
                }
                if (this._raisedState) {
                    styles += shadowBuilder(this.elevation, colorShadow);
                }
                return styles;
            });
        }
        else if (this.bg || this.color) {
            const /** @type {?} */ changeKey = this.bg ? ['bg', 'background', this.bg] : ['ĸ', 'color', this.color];
            const /** @type {?} */ color = changeKey[2];
            key = `${changeKey[0]}${color}${this._raisedState}${this.elevation}`;
            /** Create style */
            newClassName = this.theme.setStyle(`ly-${key}`, () => {
                const /** @type {?} */ _color = this.theme.colorOf(this.bg || this.color);
                let /** @type {?} */ styles = `${changeKey[1]}:${_color};`;
                if (this._raisedState) {
                    styles += shadowBuilder(this.elevation, _color);
                }
                return styles;
            });
        }
        else {
            key = `raised${this._raisedState}${this.elevation}`;
            newClassName = this.theme.setStyle(`ly-${key}`, () => {
                if (this._raisedState) {
                    return shadowBuilder(this.elevation, this.theme.palette["colorShadow"]);
                }
                else {
                    return shadowBuilder(0, this.theme.palette["colorShadow"]);
                }
            });
        }
        this.theme.updateClassName(this.elementRef.nativeElement, this.renderer, newClassName, this._currentClassName);
        this._currentClassName = newClassName;
    }
    /**
     * @return {?}
     */
    contrastStyle() {
        const /** @type {?} */ cssBg = this.theme.colorOf(this.bg);
        this._color = this.theme.colorOf(`${this.bg}:contrast`);
        let /** @type {?} */ styles = `background:${cssBg};color:${this._color};`;
        if (this._raisedState) {
            styles += shadowBuilder(this.elevation, cssBg);
        }
        return styles;
    }
    /**
     * @return {?}
     */
    bgColorStyle() {
        const /** @type {?} */ cssBg = this.theme.colorOf(this.bg);
        const /** @type {?} */ cssColor = this.theme.colorOf(this.color);
        let /** @type {?} */ styles = `background:${cssBg};color:${cssColor};`;
        if (this._raisedState) {
            styles += shadowBuilder(this.elevation, cssBg);
        }
        return styles;
    }
}
LyBgColorAndRaised.decorators = [
    { type: Directive, args: [{
                selector: '[bg], [color], [raised]'
            },] },
];
/** @nocollapse */
LyBgColorAndRaised.ctorParameters = () => [
    { type: LyTheme, },
    { type: Renderer2, },
    { type: ElementRef, },
    { type: LyShadowService, },
    { type: undefined, decorators: [{ type: Inject, args: [LY_GLOBAL_CONTRAST,] }, { type: Optional },] },
];
LyBgColorAndRaised.propDecorators = {
    "bg": [{ type: Input },],
    "color": [{ type: Input },],
    "raised": [{ type: Input },],
    "elevation": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyNewRaised {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} shadow
     */
    constructor(elementRef, renderer, shadow) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.shadow = shadow;
        this.elevation = 3;
    }
    /**
     * Default raised
     * @param {?} value
     * @return {?}
     */
    set newRaised(value) {
        this.currentClassName = this.shadow.setShadow(this.elementRef, this.renderer, [value[0] || this.elevation, value[1] || 'colorShadow'], this.currentClassName);
    }
}
LyNewRaised.decorators = [
    { type: Directive, args: [{ selector: ':not([raised])[newRaised]' },] },
];
/** @nocollapse */
LyNewRaised.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: LyShadowService, },
];
LyNewRaised.propDecorators = {
    "newRaised": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyCommonModule {
}
LyCommonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [LyBgColorAndRaised, LyNewRaised],
                exports: [LyBgColorAndRaised, LyNewRaised],
                providers: [
                    { provide: LY_GLOBAL_CONTRAST, useValue: false }
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyOverlayContainer {
    constructor() {
        if (Platform.isBrowser) {
            const /** @type {?} */ container = document.createElement('ly-overlay-container');
            document.body.appendChild(container);
            this._containerElement = container;
        }
    }
    /**
     * @return {?}
     */
    get containerElement() {
        return this._containerElement;
    }
}
LyOverlayContainer.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LyOverlayContainer.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DomService {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} overlayContainer
     */
    constructor(componentFactoryResolver, overlayContainer) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.overlayContainer = overlayContainer;
    }
    /**
     * @template T
     * @param {?} _hostViewContainerRef
     * @param {?} component
     * @param {?} template
     * @return {?}
     */
    attach(_hostViewContainerRef, component, template) {
        const /** @type {?} */ viewRef = _hostViewContainerRef.createEmbeddedView(template);
        viewRef.detectChanges();
        this._viewContainerRef = _hostViewContainerRef;
        viewRef.rootNodes.forEach(rootNode => this.addChild(rootNode));
    }
    /**
     * @param {?} child
     * @return {?}
     */
    addChild(child) {
        this.overlayContainer.containerElement.appendChild(child);
    }
    /**
     * @param {?} componentRef
     * @return {?}
     */
    getDomElementFromComponentRef(componentRef) {
        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView))
            .rootNodes[0]);
    }
    /**
     * @param {?} componentRef
     * @param {?} delay
     * @return {?}
     */
    destroyRef(componentRef, delay) {
        setTimeout(() => {
            if (this._viewContainerRef) {
                this._viewContainerRef.detach();
                this._viewContainerRef.clear();
            }
        }, delay);
    }
}
DomService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DomService.ctorParameters = () => [
    { type: ComponentFactoryResolver, },
    { type: LyOverlayContainer, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} parentContainer
 * @return {?}
 */
function LY_OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {
    return parentContainer || new LyOverlayContainer();
}
const LY_OVERLAY_CONTAINER_PROVIDER = {
    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
    provide: LyOverlayContainer,
    deps: [[new Optional(), new SkipSelf(), LyOverlayContainer]],
    useFactory: LY_OVERLAY_CONTAINER_PROVIDER_FACTORY
};
class LxDomModule {
}
LxDomModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                providers: [[DomService, LY_OVERLAY_CONTAINER_PROVIDER]]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const FocusStatus = {
    /**mouse and/or touch*/
    DEFAULT: 'default',
    /** keyboard and/or program*/
    KEYBOARD: 'keyboard',
};
class LyFocusState {
    /**
     * @param {?} elementRef
     * @param {?} _ngZone
     * @param {?} _renderer
     * @param {?} _cd
     */
    constructor(elementRef, _ngZone, _renderer, _cd) {
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        this.stateMap = new Map();
        this._eventHandlers = new Map();
        this._stateSubject = new Subject();
        this.lyFocusChange = new EventEmitter();
        this._eventOptions = /** @type {?} */ ({ passive: true });
        if (Platform.isBrowser) {
            this._eventHandlers
                .set('focus', this.on.bind(this))
                .set('blur', this.on.bind(this))
                .set('touchstart', this.on.bind(this))
                .set('mousedown', this.on.bind(this));
            const /** @type {?} */ element = elementRef.nativeElement;
            this.setTriggerElement(element);
            const /** @type {?} */ ob = this._stateSubject.asObservable();
            this._stateSubscription = ob
                .pipe(debounceTime(111))
                .subscribe((e) => {
                this.state = e;
                this._updateClass();
                this.lyFocusChange.emit(e);
            });
        }
    }
    /**
     * @return {?}
     */
    _updateState() {
        let /** @type {?} */ state;
        if (this.stateMap.has('blur')) {
            this.stateMap.clear();
        }
        else if (this.stateMap.has('focus') && this.stateMap.has('mousedown') || this.stateMap.has('focus') && this.stateMap.has('touchstart')) {
            state = FocusStatus.DEFAULT;
        }
        else if (this.stateMap.has('focus')) {
            state = FocusStatus.KEYBOARD;
        }
        this._stateSubject.next(state);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    on(event) {
        this.stateMap.set(event.type, true);
        this._updateState();
    }
    /**
     * @return {?}
     */
    _updateClass() {
        const /** @type {?} */ element = this._containerElement;
        const /** @type {?} */ state = this.state;
        const /** @type {?} */ toggleClass = (className, shouldSet) => shouldSet ? this._renderer.addClass(element, className) : this._renderer.removeClass(element, className);
        toggleClass(`ly-focused`, !!state);
        for (const /** @type {?} */ key in FocusStatus) {
            if (FocusStatus.hasOwnProperty(key)) {
                const /** @type {?} */ className = FocusStatus[key];
                toggleClass(`ly-${className}-focused`, state === className);
            }
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    setTriggerElement(element) {
        if (this._containerElement) {
            this._eventHandlers.forEach((fn, type) => {
                this._containerElement.removeEventListener(type, fn, this._eventOptions);
            });
        }
        if (element) {
            this._ngZone.runOutsideAngular(() => {
                return this._eventHandlers.forEach((fn, type) => {
                    return element.addEventListener(type, fn, this._eventOptions);
                });
            });
        }
        this._containerElement = element;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (Platform.isBrowser) {
            this._stateSubscription.unsubscribe();
            this.setTriggerElement(null);
        }
    }
}
LyFocusState.decorators = [
    { type: Directive, args: [{
                selector: '[lyFocusState]',
                exportAs: 'lyFocusState'
            },] },
];
/** @nocollapse */
LyFocusState.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
    { type: ChangeDetectorRef, },
];
LyFocusState.propDecorators = {
    "lyFocusChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyFocusStateModule {
}
LyFocusStateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [LyFocusState],
                exports: [LyFocusState]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const AUI_VERSION = '1.7.0-beta.6yqz';
const AUI_LAST_UPDATE = '2018-05-19T00:08:37.115Z';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LyThemeStyles {
    /**
     * @param {?} theme
     */
    constructor(theme) {
        this.theme = theme;
        this.classes = {};
    }
}
LyThemeStyles.decorators = [
    { type: Injectable, args: [{ providedIn: AlyleUIModule },] },
];
/** @nocollapse */
LyThemeStyles.ctorParameters = () => [
    { type: LyTheme, },
];
/** @nocollapse */ LyThemeStyles.ngInjectableDef = defineInjectable({ factory: function LyThemeStyles_Factory() { return new LyThemeStyles(inject(LyTheme)); }, token: LyThemeStyles, providedIn: AlyleUIModule });
class LyGlobalStyles {
    /**
     * @param {?} theme
     */
    constructor(theme) {
        this.theme = theme;
        this.classes = {
            /** Position absolute */
            Absolute: this.theme.setRootStyle('Absolute', () => (`position: absolute;` +
                `top: 0;` +
                `bottom: 0;` +
                `left: 0;` +
                `right: 0;`))
        };
    }
}
LyGlobalStyles.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */
LyGlobalStyles.ctorParameters = () => [
    { type: LyTheme, },
];
/** @nocollapse */ LyGlobalStyles.ngInjectableDef = defineInjectable({ factory: function LyGlobalStyles_Factory() { return new LyGlobalStyles(inject(LyTheme)); }, token: LyGlobalStyles, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { getContrastYIQ, LyTheme, mergeDeep, parsePalette, shadowBuilder, RandomId, getParents, THEME_VARIABLES, IS_CORE_THEME, StyleMap, ThemeVariables, LyRootService, Platform, Color, trim, rgbaToHex, componentToHex, toRgb, converterToHex, rgbToHex, rgbTransparent, hexToRgba, LyCommonModule, NgTranscludeDirective, NgTranscludeModule, exactPosition, toBoolean, IsBoolean, DomService, LY_OVERLAY_CONTAINER_PROVIDER_FACTORY, LY_OVERLAY_CONTAINER_PROVIDER, LxDomModule, LyFocusStateModule, FocusStatus, LyFocusState, provideTheme, AlyleUIModule, ProvidedInTheme, AUI_VERSION, AUI_LAST_UPDATE, LY_GLOBAL_CONTRAST, LyBgColorAndRaised, LyShadowService, LyThemeStyles, LyGlobalStyles, LyOverlayContainer as ɵb, LyNewRaised as ɵa };
//# sourceMappingURL=alyle-ui.js.map
