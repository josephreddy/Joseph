import { Platform, LyTheme, ProvidedInTheme, toBoolean, AlyleUIModule } from '@alyle/ui';
import { Injectable, NgModule, ElementRef, Input, Directive, NgZone, Renderer2, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';

var RippleRef = /** @class */ (function () {
    function RippleRef() {
        this.state = true;
        this.timestamp = -Date.now();
        this.container = document.createElement('span');
    }
    RippleRef.prototype.end = function () {
        this.state = false;
        this.timestamp += Date.now();
    };
    return RippleRef;
}());
var Ripple = /** @class */ (function () {
    function Ripple(_ngZone, stylesData, _containerElement, _triggerElement) {
        this._ngZone = _ngZone;
        this.stylesData = stylesData;
        this._containerElement = _containerElement;
        this._triggerElement = _triggerElement;
        this._state = true;
        this._eventHandlers = new Map();
        this.rippleConfig = {};
        this._transitionDuration = '950ms';
        this._eventOptions = ({ passive: true });
        if (Platform.isBrowser) {
            if (typeof TouchEvent === 'function' && !!TouchEvent) {
                this._eventHandlers.set('pointerdown', this.onPointerDown.bind(this));
                this._eventHandlers.set('touchend', this.onPointerLeave.bind(this));
            }
            else {
                this._eventHandlers.set('mousedown', this.onPointerDown.bind(this));
            }
            this._eventHandlers.set('mouseup', this.onPointerLeave.bind(this));
            this._eventHandlers.set('mouseleave', this.onPointerLeave.bind(this));
            if (!_triggerElement) {
                _triggerElement = _containerElement;
            }
            this.setTriggerElement(_triggerElement);
        }
    }
    Ripple.prototype.setConfig = function (config) {
        this.rippleConfig = config;
    };
    Object.defineProperty(Ripple.prototype, "_rectContainer", {
        get: function () {
            return this._containerElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    Ripple.prototype.setTriggerElement = function (element) {
        var _this = this;
        if (element) {
            element.classList.add(this.stylesData[0]);
            this._ngZone.runOutsideAngular(function () {
                _this._eventHandlers.forEach(function (fn, type) { return element.addEventListener(type, fn, _this._eventOptions); });
            });
        }
        this._triggerElement = element;
    };
    Ripple.prototype.createRipple = function (styles) {
        this._rippleRef = new RippleRef();
        var container = this._rippleRef.container;
        container.className = this.stylesData[1];
        for (var key in styles) {
            if (styles.hasOwnProperty(key)) {
                var element = styles[key];
                if (typeof element === 'number') {
                    container.style[key] = element + "px";
                }
                else {
                    container.style[key] = element;
                }
            }
        }
        this._containerElement.appendChild(container);
        window.getComputedStyle(container).getPropertyValue('opacity');
        container.style.transform = "scale(1)";
    };
    Ripple.prototype.onPointerDown = function (event) {
        if (!this.rippleConfig.disabled) {
            this.endRipple();
            this.startRipple(event, this.rippleConfig);
        }
    };
    Ripple.prototype.onPointerLeave = function (event) {
        if (!this.rippleConfig.disabled) {
            this.endRipple();
        }
    };
    Ripple.prototype.startRipple = function (event, rippleConfig) {
        var containerRect = this._rectContainer;
        var x = event.clientX, y = event.clientY;
        if (rippleConfig.centered) {
            x = containerRect.left + containerRect.width / 2;
            y = containerRect.top + containerRect.height / 2;
        }
        var left = x - containerRect.left;
        var top = y - containerRect.top;
        var radius = rippleConfig.radius === 'containerSize' ? maxSize(containerRect) / 2 : rippleConfig.radius || rippleRadius(x, y, containerRect);
        if (rippleConfig.percentageToIncrease) {
            radius += radius * rippleConfig.percentageToIncrease / 100;
        }
        var ripple = this.createRipple({
            left: left - radius,
            top: top - radius,
            width: radius * 2,
            height: radius * 2,
            transitionDuration: this._transitionDuration
        });
    };
    Ripple.prototype.runTimeoutOutsideZone = function (fn, delay) {
        if (delay === void 0) { delay = 0; }
        this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });
    };
    Ripple.prototype.endRipple = function () {
        var rippleRef = this._rippleRef || null;
        var duration = parseFloat(this._transitionDuration);
        if (rippleRef && rippleRef.state) {
            rippleRef.end();
            this.runTimeoutOutsideZone(function () {
                rippleRef.container.style.opacity = '0';
                rippleRef.container.style.transitionDuration = '200ms';
            }, rippleRef.timestamp < duration ? duration * .15 : 0);
            this.runTimeoutOutsideZone(function () {
                rippleRef.container.parentNode.removeChild(rippleRef.container);
            }, rippleRef.timestamp < duration ? duration * 2 : duration);
        }
    };
    Ripple.prototype.removeEvents = function () {
        var _this = this;
        if (this._triggerElement) {
            this._eventHandlers.forEach(function (fn, type) {
                _this._triggerElement.removeEventListener(type, fn, _this._eventOptions);
            });
        }
    };
    return Ripple;
}());
function rippleRadius(x, y, rect) {
    var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));
    var distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
    return Math.sqrt(distX * distX + distY * distY);
}
function maxSize(rect) {
    return Math.max(rect.width, rect.height);
}
var LyRippleService = /** @class */ (function () {
    function LyRippleService(theme) {
        this.theme = theme;
        this.stylesData = [];
        this.classes = {
            root: this.theme.setRootStyle('ripple', function () { return ("z-index: 0;" +
                "border-radius: inherit;"); })
        };
        var host = this.theme.setRootStyle('ripple', function () {
            return 'position: relative;';
        });
        var rippleContainer = this.theme.setRootStyle('ripple-cont', function () {
            return "position: absolute;" +
                "width: 5px;" +
                "height: 5px;" +
                "background: currentColor;" +
                "opacity: .19;" +
                "border-radius: 100%;" +
                "-webkit-transform: scale(0);" +
                "transform: scale(0);" +
                "-webkit-transition: opacity ease,-webkit-transform cubic-bezier(.1, 1, 0.5, 1);" +
                "transition: opacity ease,-webkit-transform cubic-bezier(.1, 1, 0.5, 1);" +
                "transition: opacity ease,transform cubic-bezier(.1, 1, 0.5, 1);" +
                "transition: opacity ease,transform cubic-bezier(.1, 1, 0.5, 1);" +
                "pointer-events: none;";
        });
        this.stylesData.push(host, rippleContainer);
    }
    return LyRippleService;
}());
LyRippleService.decorators = [
    { type: Injectable, args: [ProvidedInTheme,] },
];
LyRippleService.ctorParameters = function () { return [
    { type: LyTheme, },
]; };
LyRippleService.ngInjectableDef = defineInjectable({ factory: function LyRippleService_Factory() { return new LyRippleService(inject(LyTheme)); }, token: LyRippleService, providedIn: AlyleUIModule });
var LyRipple = /** @class */ (function () {
    function LyRipple(rippleService, _elementRef, _ngZone, _renderer) {
        this.rippleService = rippleService;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        if (Platform.isBrowser) {
            this.rippleContainer = new Ripple(this._ngZone, this.rippleService.stylesData, this._elementRef.nativeElement);
        }
    }
    Object.defineProperty(LyRipple.prototype, "lyRippleConfig", {
        get: function () {
            return {
                centered: toBoolean(this.lyRippleCentered),
                disabled: toBoolean(this.lyRippleDisabled),
                sensitive: toBoolean(this.lyRippleSensitive),
                radius: this.lyRippleRadius,
                percentageToIncrease: this.lyRipplePercentageToIncrease,
            };
        },
        enumerable: true,
        configurable: true
    });
    LyRipple.prototype.ngOnInit = function () {
        this._updateRipple();
    };
    LyRipple.prototype.ngOnChanges = function (changes) {
        this._updateRipple();
    };
    LyRipple.prototype._updateRipple = function () {
        if (Platform.isBrowser) {
            this.rippleContainer.setConfig(this.lyRippleConfig);
        }
    };
    LyRipple.prototype.ngOnDestroy = function () {
        if (this.rippleContainer) {
            this.rippleContainer.removeEvents();
        }
    };
    return LyRipple;
}());
LyRipple.decorators = [
    { type: Directive, args: [{
                selector: '[lyRipple], [ly-ripple]',
                exportAs: 'lyRipple'
            },] },
];
LyRipple.ctorParameters = function () { return [
    { type: LyRippleService, },
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
]; };
LyRipple.propDecorators = {
    "lyRippleCentered": [{ type: Input },],
    "lyRippleDisabled": [{ type: Input },],
    "lyRippleSensitive": [{ type: Input },],
    "lyRippleRadius": [{ type: Input },],
    "lyRipplePercentageToIncrease": [{ type: Input },],
};
var LyRippleModule = /** @class */ (function () {
    function LyRippleModule() {
    }
    return LyRippleModule;
}());
LyRippleModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [LyRipple],
                exports: [LyRipple]
            },] },
];

export { LyRippleModule, LyRipple, LyRippleService, RippleRef, Ripple };
//# sourceMappingURL=alyle-ui-ripple.js.map
